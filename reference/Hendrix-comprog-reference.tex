% -*- compile-command: "pdflatex -shell-escape Hendrix-comprog-reference.tex" -*-

\documentclass[10pt]{book}

\usepackage[margin=1in]{geometry}
\usepackage{fancyhdr}

\pagestyle{fancy}

% \lhead{\leftmark}
% \rhead{\rightmark}

% \lfoot{Hendrix Programming Team Reference}
% \rfoot{\thepage}

% TODO: make fancy header with page number and section etc.

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{hyperref}

\usepackage{titlepic}
\usepackage{graphicx}
\graphicspath{{images/}}

\usepackage{minted}
\usepackage{etoolbox}
\usepackage{mdframed}
\usepackage{booktabs}
\usepackage{xspace}
\usepackage{pifont}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Inline code

\newcommand{\code}[1]{\inputminted[fontsize=\normalsize]{java}{code/#1}}
\newcommand{\pycode}[1]{\inputminted[fontsize=\normalsize]{python}{code/#1}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Links

\newcommand*{\fulllink}[1]{\hyperref[{#1}]{\nameref*{#1}~(\S\ref*{#1}, page~\pageref*{#1})}}
\newcommand*{\link}[1]{\hyperref[{#1}]{(\S\ref*{#1}, page~\pageref*{#1})}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Kattis

\newcommand{\kattis}[1]{%
  \begin{mdframed}
  \includegraphics[height=0.9\baselineskip]{Kattis}
  \def\nextitem{\def\nextitem{, }}
  \renewcommand*{\do}[1]{\nextitem\kattislink{##1}}
  \docsvlist{#1}
  \end{mdframed}
}

\newcommand{\kattislink}[1]{\href{https://open.kattis.com/problems/#1}{\texttt{#1}}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Todos

\newif\iftodos
\todostrue
\newcommand{\todo}[1]{\iftodos\textcolor{red}{[TODO: #1]}\fi}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Warning

\newenvironment{warning}
{\par\begin{mdframed}[linewidth=2pt,linecolor=red]%
    \begin{list}{}{\leftmargin=1cm
        \labelwidth=\leftmargin}\item[\Large\ding{43}]}
    {\end{list}\end{mdframed}\par}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Misc

\newcommand{\eg}{\emph{e.g.}\xspace}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\title{Hendrix Programming Team Reference}
\titlepic{\includegraphics[width=3in]{Hendrix-logo}}
\maketitle

\tableofcontents
\newpage

\chapter{Limits}

As a rule of thumb, you should assume about $10^8$ (= 100 million)
operations per second.  If you can think of a straightforward brute
force solution to a problem, you should check whether it is likely to
fit within the time limit; if so, go for it!  Some problems are
explicitly written to see if you will recognize this.  If a brute
force solution won't fit, the input size can help guide you to search
for the right algorithm running time.

Example: suppose a problem requires you to find the length of a
shortest path in a weighted graph.
\begin{itemize}
\item If the graph has $|V| = 400$ vertices, you should use
  Floyd-Warshall: it is the easiest to code and takes $O(V^3)$ time
  which should be good enough.
\item If the graph has $|V| = 4000$ vertices, especially if it doesn't
  have all possible edges, you can use Dijkstra's algorithm, which is
  $O(E \log V)$.
\item If the graph has $|V| = 10^5$ vertices, you should look for some
  special property of the graph which allows you to solve the problem
  in $O(V)$ or $O(V \log V)$ time---for example, perhaps the graph is
  a tree, so you can run DFS to find a unique path and then add up the
  weights.  An input size of $10^5$ is a common sign that you are
  expected to use an $O(n \lg n)$ or $O(n)$ algorithm---it's big
  enough to make $O(n^2)$ too slow but not so big that the time to do
  I/O makes a big difference.
\end{itemize}

\begin{table*}[h]\centering
  \renewcommand{\arraystretch}{1.3}
  \begin{tabular}{@{}lll@{}}\toprule
    $n$ & Worst running time & Example \\
    \midrule
    $11$ & $O(n!)$ & Generating all permutations \link{sec:combinatorics} \\
    $25$ & $O(2^n)$ & Generating all subsets \link{sec:bittricks} \\
    $100$ & $O(n^4)$ & Some brute force algorithms \\
    $400$ & $O(n^3)$ & Floyd-Warshall \link{sec:floydwarshall} \\
    $10^4$ & $O(n^2)$ & Testing all pairs \\
    $10^6$ & $O(n \lg n)$ & BFS/DFS; sort+greedy \\
    \bottomrule
  \end{tabular}
\end{table*}

\kattis{bing, transportationplanning, dancerecital, prozor,
  rectanglesurrounding, weakvertices}

\begin{itemize}
\item $2^{10} = 1024 \approx 10^3$
\item One \texttt{int} is 32 bits = 4 bytes. So an array of $10^6$
  \texttt{int}s requires $< 4$ MB---typical memory limit is $1$ GB.
\item $2 \cdot 10^9$ fits in a 32-bit \texttt{int}.
\item $9 \cdot 10^{18}$ fits in a 64-bit \texttt{long}.
\item If you need larger values, use \fulllink{sec:bigint} or just use
  \fulllink{chap:python}; see \fulllink{sec:combinatorics}.
\end{itemize}

\chapter{Java Reference}

\section{Template}

\code{java/Template.java}

\section{Scanner}

\texttt{Scanner} is relatively slow but should usually be sufficient
for most purposes.  If the input or output is relatively large (> 1MB)
and you suspect the time taken to read or write it may be a hindrance,
you can use \fulllink{sec:fastio}.

\code{java/ScannerExample.java}

\section{String}

The \texttt{String} type can be used in Java to represent sequences of
characters.

\todo{Useful \texttt{String} methods: concatenation, substring, charAt, \dots?}
\todo{Converting between \texttt{String} and \texttt{char[]},
  advantages and disadvantages of each}

\kattis{battlesimulation, bing, connectthedots, itsasecret, shiritori,
suffixarrayreconstruction}

\section{Arrays}

\todo{Basic array template/examples.}

\kattis{falcondive,freefood,traveltheskies}

\section{ArrayList}

\todo{Basic template and examples.  Useful \texttt{ArrayList} methods:
  \texttt{add}, \texttt{get}, \texttt{set}.  Advantages/disadvantages
  compared to arrays.}

\section{Stack}

\todo{Example using \texttt{Stack} class.}
\todo{Mention balanced parentheses, DFS}

\kattis{backspace, islands, pairingsocks, reservoir, restaurant,
  throwns, zagrade}

\section{Queue}

\todo{\texttt{Queue} interface, \texttt{ArrayDeque} class}

\kattis{brexit, coconut, ferryloading4, shuffling}

\section{PriorityQueue}

\todo{Examples of using \texttt{PriorityQueue}.  Show how to
  construct with custom \texttt{Comparator}, eg. using lambda notation}
\todo{Note lack of decreaseKey operation (Dijkstra), use remove + add,
  not as fast}

\kattis{bank, guessthedatastructure, knigsoftheforest}

\section{Set}

\todo{HashSet, TreeSet}

\section{Map}

\todo{HashMap, TreeMap}

\section{BigInteger} \label{sec:bigint}

\todo{Examples.  Useful methods, constructors (gcd, mod, base conversion!).}

\kattis{basicremains}

\section{Sorting}

\todo{Basic template for implementing Comparable}
\todo{Arrays.sort, Collections.sort}
\todo{Include code for basic sorting implementations (in case it's
  useful to code them up explicitly so they can be enhanced with extra
  info): insertion sort, mergesort, quicksort)}

\section{BitSet}

\todo{Basic examples of BitSet use.}

\kattis{primesieve}

\section{Fast I/O} \label{sec:fastio}

Typically ACM ICPC problems are designed so \texttt{Scanner} and
\texttt{System.out.println} are fast enough to read and write the
required input and output within the time limits.  However, these are
relatively slow since they are unbuffered (every single read and write
happens immediately).  Occasionally it can be useful to have faster
I/O; indeed, some problems on Kattis cannot be solved in Java without
using this. \todo{Link to some examples.}

\begin{warning}
  Be sure to call \texttt{flush()} at the end of your program
  or else some output might be lost!
\end{warning}

\code{java/Kattio.java}

\todo{Add \texttt{getLine()} method}

\chapter{Data Structures}

\section{Union-find}

A union-find structure can be used to keep track of a collection of
disjoint sets, with the ability to quickly test whether two items are
in the same set, and to quickly union two given sets into one.  It is
used in Kruskal's Minimum Spanning Tree algorithm \link{sec:kruskal},
and can also be useful on its own.  \texttt{find} and \texttt{union}
both take essentially constant amortized time.

\kattis{drivingrange, islandhopping, kastenlauf, lostmap, minspantree,
  numbersetseasy, treehouses, unionfind, virtualfriends,
  wheresmyinternet}

\code{data-structures/UnionFind.java}

\section{Heaps}

\section{Tries}

\kattis{boggle, heritage, phonelist}

\section{Red-black trees}

\section{Segment trees}

\section{Fenwick trees}

\chapter{Search}

\section{Complete search}

\todo{Complete search aka brute force}

\section{Binary and ternary search}

\todo{Binary search on an array; binary search on unbounded function
  on the integers; binary search on real interval; ternary search}

\chapter{Graphs}

\section{Tips \& tricks}

\todo{characterization of trees}
\todo{New virtual source/sink node trick}

\section{Graph representation}

\todo{Adjacency matrix, adjacency maps.  Edge objects. Implicit graphs.}

\section{BFS}

\todo{Code for BFS with level labelling, parent map.}

\kattis{brexit}

\section{DFS, SCCs, topological sorting}

\todo{Code for DFS, start/finish labelling, top sorting, Tarjan's SCC algorithm}

\section{Single-source shortest paths (Dijkstra)}

\section{All-pairs shortest paths (Floyd-Warshall)} \label{sec:floydwarshall}

\section{Min spanning trees (Kruskal)} \label{sec:kruskal}

\section{Max flow}

A \emph{flow network} is a directed, weighted graph where the edge
weights (typically integers) are thought of as representing
\emph{capacities} (\eg imagine pipes of varying sizes).  The \emph{max
  flow problem} is to determine, given a flow network, the maximum
possible amount of \emph{flow} which can move through the network
between given source and sink vertices, subject to the constraints
that the flow on any edge is no greater than the capacity, and the sum
of incoming flows equals outgoing flows at every vertex other than the
source or sink.  Flow networks can be used to model a wide variety of
problems.

\todo{Enumerate a few problem types: item assignment; max bipartite
  matching; min cut}

\todo{choose directed/undirected edges carefully!}

\todo{Requires vertices $0 \dots n-1$: either carefully keep track of
  which numbers are for which vertices, or use lookup tables}

\kattis{copsandrobbers,escapeplan,gopher2,guardianofdecency,marblestree,maxflow,mincut,paintball,waif}

Dinitz' Algorithm is probably the best all-around algorithm to use for
solving max flow problems in competitive programming.  It takes
$O(V^2 E)$ in theory (although is often much faster in practice).  In
the special case where we are modelling a bipartite matching problem,
Dinitz' Algorithm reduces to the Hopcroft-Karp algorithm which runs in
$O(E \sqrt{V})$.

\code{flow/Dinitz.java}

\todo{Include a sample solution using a flow network}

\chapter{Dynamic Programming}

\chapter{Strings}

\section{Suffix arrays}

\chapter{Divide \& Conquer}

\section{Counting inversions}

\kattis{excursion, froshweek}

\chapter{Mathematics}

\section{GCD/Euclidean Algorithm}

\section{Fractions}

\section{Primes and factorization}

\todo{Basic primality testing and factorization with trial division.
  Sieving (primes, factors, Euler totient).}

\section{Combinatorics} \label{sec:combinatorics}

\todo{Basic principles of combinatorics.  Code for computing binomial
  coefficients.}

\todo{mod $10^9 + 7$.}

\begin{warning}
  Remember to use \texttt{long} if you need an answer
  $\bmod (10^9 + 7)$ (which would fit in an \texttt{int}) but
  computing the answer requires \emph{multiplying} $\bmod (10^9 + 7)$.
\end{warning}

\todo{Heap's Algorithm for generating all permutations.  See Bit
  Tricks for generating all subsets.}

\todo{PIE?}

\chapter{Bit Tricks} \label{sec:bittricks}

\todo{Basic bit manipulation.  Using bitstrings to compactly represent
  sets/states.  Iterating through all subsets with counter.}

\todo{BitSet instead of array of booleans.}

\chapter{Geometry}

\todo{Points, vectors, angles.  Degrees/radians. \texttt{atan2}. Dot
  product. Rotation. Vector magnitude, norm (squared), normalize.
  Perpendicular (generate, test).}
\todo{Cross product in 2D. Signed area (parallelogram, triangle),
  polygon area, right/left turn, inside/outside testing.}
\todo{Lines/rays (point + vector).  Line intersection. Segment
  intersection. Closest point on a line/segment.}
\todo{Convex hull.}

\chapter{Miscellaneous}

\section{Range queries}

\todo{Monoid vs group}
\todo{Prefix sum trick}
\todo{2D prefix sum trick with PIE}
\todo{Kadena's Algorithm for max subsequence sum}
\todo{Segment trees, Fenwick trees}

\section{2D grids}

\todo{Discussion of implicit graphs}
\todo{Formulas for converting between pair of coordinates and single index}
\todo{Trick for listing neighbors with delta vector}

\chapter{Python} \label{chap:python}

Python's built-in support for arbitrary-size integers (using
\texttt{BigInteger} in Java is a pain!) and built-in dictionaries with
lightweight syntax make it attractive for certain kinds of problems.

Below is a basic template showing how to read typical contest problem
input in Python:

\pycode{python/template.py}

\todo{Mention basic Python data structures such as set, deque, list methods}

\end{document}
