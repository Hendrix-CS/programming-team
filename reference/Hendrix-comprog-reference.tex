% -*- compile-command: "pdflatex -shell-escape Hendrix-comprog-reference.tex" -*-

\documentclass[10pt]{book}

\usepackage[margin=1in]{geometry}
\usepackage{fancyhdr}

\pagestyle{fancy}

% \lhead{\leftmark}
% \rhead{\rightmark}

% \lfoot{Hendrix Programming Team Reference}
% \rfoot{\thepage}

% TODO: make fancy header with page number and section etc.

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{hyperref}

\usepackage{titlepic}
\usepackage{graphicx}
\graphicspath{{images/}}

\usepackage[newfloat]{minted}
\usepackage{etoolbox}
\usepackage{mdframed}
\usepackage{booktabs}
\usepackage{xspace}
\usepackage{pifont}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Inline code

\newcommand{\code}[1]{\inputminted[fontsize=\normalsize]{java}{code/#1}}
\newcommand{\pycode}[1]{\inputminted[fontsize=\normalsize]{python}{code/#1}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Links

\newcommand*{\fulllink}[1]{\hyperref[{#1}]{\nameref*{#1}~(\S\ref*{#1}, page~\pageref*{#1})}}
\newcommand*{\link}[1]{\hyperref[{#1}]{(\S\ref*{#1}, page~\pageref*{#1})}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Kattis

\newcommand{\kattis}[1]{%
  \begin{mdframed}
  \includegraphics[height=0.9\baselineskip]{Kattis}
  \def\nextitem{\def\nextitem{, }}
  \renewcommand*{\do}[1]{\nextitem\kattislink{##1}}
  \docsvlist{#1}
  \end{mdframed}
}

\newcommand{\kattislink}[1]{\href{https://open.kattis.com/problems/#1}{\texttt{#1}}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Todos

\newif\iftodos
\todostrue
\newcommand{\todo}[1]{\iftodos\textcolor{red}{[TODO: #1]}\fi}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Warning

\newenvironment{warning}
{\par\begin{mdframed}[linewidth=2pt,linecolor=red]%
    \begin{list}{}{\leftmargin=1cm
        \labelwidth=\leftmargin}\item[\Large\ding{43}]}
    {\end{list}\end{mdframed}\par}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Misc

\newcommand{\eg}{\emph{e.g.}\xspace}
\newcommand{\ie}{\emph{i.e.}\xspace}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\title{Hendrix Programming Team Reference}
\titlepic{\includegraphics[width=3in]{Hendrix-logo}}
\maketitle

\tableofcontents
\newpage

\chapter{Limits}

As a rule of thumb, you should assume about $10^8$ (= 100 million)
operations per second.  If you can think of a straightforward brute
force solution to a problem, you should check whether it is likely to
fit within the time limit; if so, go for it!  Some problems are
explicitly written to see if you will recognize this.  If a brute
force solution won't fit, the input size can help guide you to search
for the right algorithm running time.

Example: suppose a problem requires you to find the length of a
shortest path in a weighted graph.
\begin{itemize}
\item If the graph has $|V| = 400$ vertices, you should use
  Floyd-Warshall \link{sec:floydwarshall}: it is the easiest to code and takes $O(V^3)$ time
  which should be good enough.
\item If the graph has $|V| = 4000$ vertices, especially if it doesn't
  have all possible edges, you can use Dijkstra's algorithm
  \link{sec:dijkstra}, which is $O(E \log V)$.
\item If the graph has $|V| = 10^5$ vertices, you should look for some
  special property of the graph which allows you to solve the problem
  in $O(V)$ or $O(V \log V)$ time---for example, perhaps the graph is
  a tree \link{sec:graph-basics}, so you can run a DFS \link{sec:dfs}
  to find a unique path and then add up the weights.  An input size of
  $10^5$ is a common sign that you are expected to use an $O(n \lg n)$
  or $O(n)$ algorithm---it's big enough to make $O(n^2)$ too slow but
  not so big that the time to do I/O makes a big difference.
\end{itemize}

\begin{table*}[h]\centering
  \renewcommand{\arraystretch}{1.3}
  \begin{tabular}{@{}lll@{}}\toprule
    $n$ & Worst viable running time & Example \\
    \midrule
    $11$ & $O(n!)$ & Generating all permutations \link{sec:combinatorics} \\
    $25$ & $O(2^n)$ & Generating all subsets \link{sec:bittricks} \\
    $100$ & $O(n^4)$ & Some brute force algorithms \\
    $400$ & $O(n^3)$ & Floyd-Warshall \link{sec:floydwarshall} \\
    $10^4$ & $O(n^2)$ & Testing all pairs \\
    $10^6$ & $O(n \lg n)$ & BFS/DFS; sort+greedy \\
    \bottomrule
  \end{tabular}
\end{table*}

\kattis{bing, transportationplanning, dancerecital, prozor,
  rectanglesurrounding, weakvertices}

\begin{itemize}
\item $2^{10} = 1024 \approx 10^3$.
\item One \texttt{int} is 32 bits = 4 bytes. So \emph{e.g.} an array
  of $10^6$ \texttt{int}s requires $< 4$ MB---no big deal since the
  typical memory limit is $1$ GB.  Don't be afraid to make arrays with
  millions of elements!
\item \texttt{int} holds 32 bits; the largest \texttt{int} value is
  \verb|Integer.MAX_VALUE| $ = 2^{31} - 1$, a bit more than
  $2 \cdot 10^9$.
\item \texttt{long} holds 64 bits; the largest
  \texttt{long} value is \verb|Long.MAX_VALUE| $ = 2^{63} - 1$, a bit
  more than $9 \cdot 10^{18}$.
\item If you need larger values, use \fulllink{sec:bigint} or just use
  \fulllink{chap:python}; see \fulllink{sec:combinatorics}.
\end{itemize}

\chapter{Java Reference}

\section{Template}

\code{java/Template.java}

\section{Scanner}

\texttt{Scanner} is relatively slow but should usually be sufficient
for most purposes.  If the input or output is relatively large (> 1MB)
and you suspect the time taken to read or write it may be a hindrance,
you can use \fulllink{sec:fastio}.

\code{java/ScannerExample.java}

\section{String}

The \texttt{String} type can be used in Java to represent sequences of
characters.

\todo{Useful \texttt{String} methods: concatenation, substring, charAt, \dots?}
\todo{Converting between \texttt{String} and \texttt{char[]},
  advantages and disadvantages of each}

\kattis{battlesimulation, bing, connectthedots, itsasecret, shiritori,
suffixarrayreconstruction}

\section{Arrays}

\todo{Basic array template/examples.}
\todo{Useful \texttt{Arrays} methods: sort, copyOf, copyOfRange, fill, binarySearch}

\kattis{falcondive,freefood,traveltheskies}

\section{ArrayList}

\todo{Basic template and examples.  Useful \texttt{ArrayList} methods:
  \texttt{add}, \texttt{get}, \texttt{set}.  Advantages/disadvantages
  compared to arrays.}

\section{Stack}

\todo{Example using \texttt{Stack} class.}
\todo{Mention balanced parentheses, DFS}

\kattis{backspace, islands, pairingsocks, reservoir, restaurant,
  throwns, zagrade}

\section{Queue}

\todo{\texttt{Queue} interface, \texttt{ArrayDeque} class}

\kattis{brexit, coconut, ferryloading4, shuffling}

\section{PriorityQueue}

\todo{Examples of using \texttt{PriorityQueue}.  Show how to
  construct with custom \texttt{Comparator}, eg. using lambda notation}
\todo{Note lack of decreaseKey operation (Dijkstra), use remove + add,
  not as fast}

\kattis{bank, guessthedatastructure, knigsoftheforest}

\section{Set}

\todo{HashSet, TreeSet}

\section{Map}

\todo{HashMap, TreeMap}
\todo{Iterating over keys, values, both (MapEntry)}

\section{BigInteger} \label{sec:bigint}

\todo{Examples.  Useful methods, constructors (gcd, mod, base conversion!).}

\kattis{basicremains}

\section{Sorting}

\todo{Basic template for implementing Comparable}
\todo{Arrays.sort, Collections.sort}
\todo{Sorting with a custom \texttt{Comparator}}
\todo{Include code for basic sorting implementations (in case it's
  useful to code them up explicitly so they can be enhanced with extra
  info): insertion sort, mergesort, quicksort)}

\section{BitSet}

\todo{Basic examples of BitSet use.}

\kattis{primesieve}

\section{Fast I/O} \label{sec:fastio}

Typically ACM ICPC problems are designed so \texttt{Scanner} and
\texttt{System.out.println} are fast enough to read and write the
required input and output within the time limits.  However, these are
relatively slow since they are unbuffered (every single read and write
happens immediately).  Occasionally it can be useful to have faster
I/O; indeed, some problems on Kattis cannot be solved in Java without
using this. \todo{Link to some examples.}

\begin{warning}
  Be sure to call \texttt{flush()} at the end of your program
  or else some output might be lost!
\end{warning}

\code{java/Kattio.java}

\todo{Add \texttt{getLine()} method}

\chapter{Data Structures}

\section{Union-find}

A union-find structure can be used to keep track of a collection of
disjoint sets, with the ability to quickly test whether two items are
in the same set, and to quickly union two given sets into one.  It is
used in Kruskal's Minimum Spanning Tree algorithm \link{sec:kruskal},
and can also be useful on its own.  \texttt{find} and \texttt{union}
both take essentially constant amortized time.

\kattis{drivingrange, islandhopping, kastenlauf, lostmap, minspantree,
  numbersetseasy, treehouses, unionfind, virtualfriends,
  wheresmyinternet}

\code{data-structures/UnionFind.java}

\section{Heaps}

\section{Tries}

\kattis{boggle, heritage, phonelist}

\section{Red-black trees}

\section{Segment trees}

\section{Fenwick trees}

\chapter{Search}

\section{Complete search}

\todo{Complete search aka brute force}

\section{Binary and ternary search}

\todo{Binary search on an array; binary search on unbounded function
  on the integers; binary search on real interval; ternary search}
\todo{Point out \texttt{Arrays.binarySearch}}

\chapter{Graphs}

\section{Graph basics} \label{sec:graph-basics}

\todo{Directed, undirected, weighted, unweighted, self loops, multiple edges}
\todo{characterization of trees}
\todo{New virtual source/sink node trick}

\section{Graph representation}

\todo{Adjacency matrix, adjacency maps.  Edge objects. Implicit graphs.}

\section{BFS}

\todo{Code for BFS with level labelling, parent map.}

\kattis{brexit}

\section{DFS, SCCs, topological sorting} \label{sec:dfs}

\todo{Code for DFS, start/finish labelling, top sorting, Tarjan's SCC algorithm}

\section{Single-source shortest paths (Dijkstra)} \label{sec:dijkstra}

\section{All-pairs shortest paths (Floyd-Warshall)} \label{sec:floydwarshall}

\section{Min spanning trees (Kruskal)} \label{sec:kruskal}

\section{Max flow}

A \emph{flow network} is a directed, weighted graph where the edge
weights (typically integers) are thought of as representing
\emph{capacities} (\eg imagine pipes of varying sizes).  The \emph{max
  flow problem} is to determine, given a flow network, the maximum
possible amount of \emph{flow} which can move through the network
between given source and sink vertices, subject to the constraints
that the flow on any edge is no greater than the capacity, and the sum
of incoming flows equals outgoing flows at every vertex other than the
source or sink.  Flow networks can be used to model a wide variety of
problems.

\todo{Enumerate a few problem types: item assignment; max bipartite
  matching; min cut}

\todo{choose directed/undirected edges carefully!}

\todo{Requires vertices $0 \dots n-1$: either carefully keep track of
  which numbers are for which vertices, or use lookup tables}

\kattis{copsandrobbers,escapeplan,gopher2,guardianofdecency,marblestree,maxflow,mincut,paintball,waif}

Dinitz' Algorithm is probably the best all-around algorithm to use for
solving max flow problems in competitive programming.  It takes
$O(V^2 E)$ in theory (although is often much faster in practice).  In
the special case where we are modelling a bipartite matching problem,
Dinitz' Algorithm reduces to the Hopcroft-Karp algorithm which runs in
$O(E \sqrt{V})$.

\code{flow/Dinitz.java}

\todo{Include a sample solution using a flow network}

\chapter{Dynamic Programming}

\chapter{Strings}

\section{Suffix arrays}

\chapter{Divide \& Conquer}

\section{Counting inversions}

\kattis{excursion, froshweek}

\chapter{Mathematics}

\section{GCD/Euclidean Algorithm}

\section{Fractions}

\section{Primes and factorization}

\todo{Basic primality testing and factorization with trial division.
  Sieving (primes, factors, Euler totient).}

\section{Combinatorics} \label{sec:combinatorics}

\todo{Basic principles of combinatorics.  Code for computing binomial
  coefficients.}

\todo{mod $10^9 + 7$.}

\begin{warning}
  Remember to use \texttt{long} if you need an answer
  $\bmod (10^9 + 7)$ (which would fit in an \texttt{int}) but
  computing the answer requires \emph{multiplying} $\bmod (10^9 + 7)$.
\end{warning}

\todo{Heap's Algorithm for generating all permutations.  See Bit
  Tricks for generating all subsets.}

\todo{PIE?}

\chapter{Bit Tricks} \label{sec:bittricks}

\todo{Basic bit manipulation.  Using bitstrings to compactly represent
  sets/states.  Iterating through all subsets with counter.}

\kattis{flipfive}

\todo{BitSet instead of array of booleans.}

\chapter{Geometry}

\todo{Points, vectors, angles.  Degrees/radians. \texttt{atan2}. Dot
  product. Rotation. Vector magnitude, norm (squared), normalize.
  Perpendicular (generate, test).}
\todo{Cross product in 2D. Signed area (parallelogram, triangle),
  polygon area, right/left turn, inside/outside testing.}
\todo{Lines/rays (point + vector).  Line intersection. Segment
  intersection. Closest point on a line/segment.}
\todo{Convex hull.}

\chapter{Miscellaneous}

\section{2D grids}

\todo{Discussion of implicit graphs}


\todo{Formulas for converting between pair of coordinates and single index}
\todo{Trick for listing neighbors with delta vector}

\section{Range queries}

Suppose we have a $1$-indexed array $A[1 \dots n]$ containing some
values, and there is some operation $\oplus$ which takes two values
and combines them to produce a new value.  Given indices $i$ and $j$,
we want to quickly find the value that results from combining all the
values in the range $A[i \dots j]$, \ie $A[i] \oplus A[i+1] \oplus
\dots \oplus A[j]$.

For example, $A$ could be an array of integers, and $\oplus$ could be
$\max$, that is, we want to find the maximum value in the range
$A[i \dots j]$.  Likewise $\oplus$ could be sum, or product, or GCD.
Or $A$ could be an array of booleans, and we want to find the AND, OR,
or XOR of the range $A[i \dots j]$.

\begin{itemize}
\item For this to make sense, the combining operation must typically
  be \emph{associative}, \ie $a \oplus (b \oplus c) = (a \oplus b) \oplus
  c$.  (This is called a \emph{semigroup}.)
\item Sometimes there is also an inverse operation $\ominus$ which
  ``cancels out'' the effects of the combining operation (this is
  called a \emph{group}).  For example, subtraction cancels out
  addition. On the other hand, there is no operation that can cancel
  out the effect of taking a maximum.
\item If we only need to find the value of combining a \emph{single}
  range $A[i \dots j]$, then ignore everything in this section and
  simply iterate through the interval, combining all the values in
  $O(n)$ time.
\item More typically, we need to do many queries, and $O(n)$ per query
  is not fast enough.  The idea is to preprocess the array into a data
  structure which allows us to answer queries more quickly, \ie in
  $O(1)$ or $O(\lg n)$.
\item Sometimes we also need to be able to \emph{update} the array in
  between queries; in this case we need a more sophisticated query
  data structure that can be quickly updated.
\end{itemize}

Each of the below subsections outlines one approach to solving this
problem; for quick reference, each subsection title says whether an
inverse operation is required, how fast queries are, and whether the
technique can handle updates.

\subsection{Prefix scan (inverse required; $O(1)$ queries; no updates)}

In a situation where we have an inverse operation and we do not need
to update the array, there is a very simple solution.  First, make
a \emph{prefix scan array} $P[0 \dots n]$ such that $P[i]$
stores the value that results from combining $A[1 \dots i]$.  ($P[0]$
stores the ``identity'' value, \eg zero if the combining operation is
sum.)  $P$ can be computed in linear time by scanning from left to
right; each $P[i] = P[i-1] \oplus A[i]$.  Now the value of $A[i \dots
j]$ can be computed in $O(1)$ time as $P[j] \ominus P[i-1]$.

Note that having $P[0]$ store the identity value is not strictly
necessary, but it removes the need for a special case.  If $A$ is
already $0$-indexed instead of $1$-indexed, then it's probably easier
to just put in a special case for looking up the value of $A[0 \dots
j]$ as $P[j]$, without the need for an inverse operation.

For example, suppose we are given an array of $10^5$ integers, along
with $10^5$ pairs $(i,j)$ for which we must output the sum of
$A[i \dots j]$.  Simply adding up the values in each range would be
too slow. We could solve this with the following code:

\code{range/PrefixSum.java}

\subsection{Kadena's Algorithm}

\todo{Kadena's Algorithm for max subsequence sum}

\subsection{2D prefix scan}

\todo{2D prefix sum trick with PIE}

\subsection{Doubling windows (no inverse; $O(1)$ queries; no updates)}

\subsection{Segment trees (no inverse; $O(\lg n)$ queries; $O(\lg n)$
  updates)}

\todo{Segment trees}

\subsection{Fenwick trees (inverse required; $O(\lg n)$ queries;
  $O(\lg n)$ updates}

\chapter{Python} \label{chap:python}

Python's built-in support for arbitrary-size integers (using
\texttt{BigInteger} in Java is a pain!) and built-in dictionaries with
lightweight syntax make it attractive for certain kinds of problems.

Below is a basic template showing how to read typical contest problem
input in Python:

\pycode{python/template.py}

\todo{Mention basic Python data structures such as set, deque, list methods}

\end{document}
